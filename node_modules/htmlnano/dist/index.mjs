import posthtml from 'posthtml';
import { cosmiconfigSync } from 'cosmiconfig';
import safePreset from './presets/safe.mjs';
import ampSafePreset from './presets/ampSafe.mjs';
import maxPreset from './presets/max.mjs';

const presets = {
    safe: safePreset,
    ampSafe: ampSafePreset,
    max: maxPreset
};
function loadConfig(options, preset, configPath) {
    const { skipConfigLoading = false, ...rest } = options || {};
    let restConfig = rest;
    if (!skipConfigLoading) {
        const explorer = cosmiconfigSync('htmlnano');
        const rc = configPath ? explorer.load(configPath) : explorer.search();
        if (rc) {
            const { preset: presetName } = rc.config;
            if (presetName) {
                if (!preset && presetName in presets) {
                    preset = presets[presetName];
                }
                delete rc.config.preset;
            }
            if (!options) {
                restConfig = rc.config;
            }
        }
    }
    return [
        restConfig || {},
        preset || safePreset
    ];
}
const optionalDependencies = {
    minifyCss: [
        'cssnano',
        'postcss'
    ],
    minifyJs: [
        'terser'
    ],
    minifyUrls: [
        'relateurl',
        'srcset',
        'terser'
    ],
    minifySvg: [
        'svgo'
    ]
};
const interop = (imported)=>imported.then((mod)=>mod.default);
const modules = {
    collapseAttributeWhitespace: ()=>interop(import('./_modules/collapseAttributeWhitespace.mjs')),
    collapseBooleanAttributes: ()=>interop(import('./_modules/collapseBooleanAttributes.mjs')),
    collapseWhitespace: ()=>interop(import('./_modules/collapseWhitespace.mjs')),
    custom: ()=>interop(import('./_modules/custom.mjs')),
    deduplicateAttributeValues: ()=>interop(import('./_modules/deduplicateAttributeValues.mjs')),
    // example: () => import('./_modules/example.mjs'),
    mergeScripts: ()=>interop(import('./_modules/mergeScripts.mjs')),
    mergeStyles: ()=>interop(import('./_modules/mergeStyles.mjs')),
    minifyConditionalComments: ()=>interop(import('./_modules/minifyConditionalComments.mjs')),
    minifyCss: ()=>interop(import('./_modules/minifyCss.mjs')),
    minifyJs: ()=>interop(import('./_modules/minifyJs.mjs')),
    minifyJson: ()=>interop(import('./_modules/minifyJson.mjs')),
    minifySvg: ()=>interop(import('./_modules/minifySvg.mjs')),
    minifyUrls: ()=>interop(import('./_modules/minifyUrls.mjs')),
    normalizeAttributeValues: ()=>interop(import('./_modules/normalizeAttributeValues.mjs')),
    removeAttributeQuotes: ()=>interop(import('./_modules/removeAttributeQuotes.mjs')),
    removeComments: ()=>interop(import('./_modules/removeComments.mjs')),
    removeEmptyAttributes: ()=>interop(import('./_modules/removeEmptyAttributes.mjs')),
    removeOptionalTags: ()=>interop(import('./_modules/removeOptionalTags.mjs')),
    removeRedundantAttributes: ()=>interop(import('./_modules/removeRedundantAttributes.mjs')),
    removeUnusedCss: ()=>interop(import('./_modules/removeUnusedCss.mjs')),
    sortAttributes: ()=>interop(import('./_modules/sortAttributes.mjs')),
    sortAttributesWithLists: ()=>interop(import('./_modules/sortAttributesWithLists.mjs'))
};
function htmlnano(optionsRun = {}, presetRun) {
    // eslint-disable-next-line prefer-const -- re-assign options
    let [options, preset] = loadConfig(optionsRun, presetRun);
    const minifier = async (_tree)=>{
        const tree = _tree;
        const nodeHandlers = [];
        const attrsHandlers = [];
        const contentsHandlers = [];
        options = {
            ...preset,
            ...options
        };
        let promise = Promise.resolve(tree);
        for (const [moduleName, moduleOptions] of Object.entries(options)){
            if (!moduleOptions) {
                continue;
            }
            if (!(moduleName in safePreset)) {
                throw new Error('Module "' + moduleName + '" is not defined');
            }
            if (moduleName in optionalDependencies) {
                const modules = optionalDependencies[moduleName];
                await Promise.all(modules.map(async (dependency)=>{
                    try {
                        await import(dependency);
                    } catch (e) {
                        if (typeof e === 'object' && e !== null && 'code' in e && typeof e.code === 'string') {
                            if (e.code === 'MODULE_NOT_FOUND' || e.code === 'ERR_MODULE_NOT_FOUND') {
                                if (!options.skipInternalWarnings) {
                                    console.warn(`You have to install "${dependency}" in order to use htmlnano's "${moduleName}" module`);
                                    return;
                                }
                            }
                            throw e;
                        }
                    }
                }));
            }
            const mod = moduleName in modules ? await modules[moduleName]() : await import(`./_modules/${moduleName}.mjs`);
            if (typeof mod.onAttrs === 'function') {
                attrsHandlers.push(mod.onAttrs(options, moduleOptions));
            }
            if (typeof mod.onContent === 'function') {
                contentsHandlers.push(mod.onContent(options, moduleOptions));
            }
            if (typeof mod.onNode === 'function') {
                nodeHandlers.push(mod.onNode(options, moduleOptions));
            }
            if (typeof mod.default === 'function') {
                promise = promise.then(async (tree)=>await mod.default(tree, options, moduleOptions));
            }
        }
        if (attrsHandlers.length + contentsHandlers.length + nodeHandlers.length === 0) {
            return promise;
        }
        return promise.then((tree)=>{
            tree.walk((node)=>{
                if (node) {
                    if (node.attrs && typeof node.attrs === 'object') {
                        // Convert all attrs' key to lower case
                        let newAttrsObj = {};
                        Object.entries(node.attrs).forEach(([attrName, attrValue])=>{
                            newAttrsObj[attrName.toLowerCase()] = attrValue;
                        });
                        for (const handler of attrsHandlers){
                            newAttrsObj = handler(newAttrsObj, node);
                        }
                        node.attrs = newAttrsObj;
                    }
                    if (node.content) {
                        node.content = typeof node.content === 'string' ? [
                            node.content
                        ] : node.content;
                        if (Array.isArray(node.content) && node.content.length > 0) {
                            for (const handler of contentsHandlers){
                                var _node_content;
                                const result = handler((_node_content = node.content) != null ? _node_content : [], node);
                                node.content = Array.isArray(result) ? result : [
                                    result
                                ];
                            }
                        }
                    }
                    for (const handler of nodeHandlers){
                        if (handler) {
                            node = handler(node);
                        }
                    }
                }
                return node;
            });
            return tree;
        });
    };
    return minifier;
}
function getRequiredOptionalDependencies(optionsRun, presetRun) {
    const [options] = loadConfig(optionsRun, presetRun);
    return Array.from(Object.keys(options).reduce((acc, moduleName)=>{
        if (moduleName in optionalDependencies) {
            const dependencies = optionalDependencies[moduleName];
            // eslint-disable-next-line @typescript-eslint/unbound-method -- thisArg provided by forEach
            dependencies.forEach(acc.add, acc);
        }
        return acc;
    }, new Set()));
}
function process(html, options, preset, postHtmlOptions) {
    return posthtml([
        htmlnano(options, preset)
    ]).process(html, postHtmlOptions);
}
// https://github.com/webpack-contrib/html-minimizer-webpack-plugin/blob/faca00f2219514bc671c5942685721f0b5dbaa70/src/utils.js#L74
function htmlMinimizerWebpackPluginMinify(input, minimizerOptions) {
    const [[, code]] = Object.entries(input);
    return htmlnano.process(code, minimizerOptions, presets.safe).then((result)=>{
        return {
            code: result.html
        };
    });
}
htmlnano.presets = presets;
htmlnano.getRequiredOptionalDependencies = getRequiredOptionalDependencies;
htmlnano.process = process;
htmlnano.htmlMinimizerWebpackPluginMinify = htmlMinimizerWebpackPluginMinify;
htmlnano.loadConfig = loadConfig;
if (typeof module !== 'undefined') {
    module.exports = htmlnano;
}

export { htmlnano as default, getRequiredOptionalDependencies, htmlMinimizerWebpackPluginMinify, htmlnano, loadConfig, process };
